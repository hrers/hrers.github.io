# 精炼
*  领域模型中的战略精炼
	1.  帮助所有团队成员掌握系统的总体设计以及各部分如何协调工作
	2. 找到一个具有适度规模的核心模型并把它添加到通用语言中，从而促进沟通
	3. 知道重构
	4. 专注于模型中最具价值的部分
	5. 指导外包，现有组件的使用以及任务委派
	
## Core Domain
	 在设计大型系统时，有非常多的组成部分——他们都很复杂并且对开发的成功也至关重要，但这导致真正的业务资产——领域模型最为精华的部分——被掩盖和忽略了。
* 一个严峻的现实是我们不可能对所有设计部分进行同等的精华，而是必须分出优先级。为了使领域模型成为有价值的资产，必须整齐地梳理出领域的真正核心，并完全根据这个核心来创建应用程序的功能。但本来就稀缺的水平开发人员往往会把工作中心放在技术基础设施上，或者只是去解决那些不需要专门领域知识就能理解的领域问题(这些问题都已经有了很好的定义).
	* 计算机科学家对系统的这部分更感兴趣，他们认为通过这些工作可以让具备一些在其他地方也能排上用场的专业技能，同时也丰富了跟人简历。而真正体现应用程序价值并且是指成为业务资产的领域核心却通常是由那些技术水平稍差的开发人员完成的，他们与DBA一起创建数据模式，然后逐个特性编写代码，而根本没有对模型的概念能力加一任何利用。
* 在指定项目规划的时候，必须把资源分配给模型和设计中最关键的部分。要达到这个目的，在规划和开发期间每个人都必须识别和理解这些关键部分。
   这些关键部分是应用程序的标志部分，也是目标应用程序的核心诉求，他们构成了Core Domain.Core Domain是系统中最具价值的部分。**对模型进行提炼，找到Core Domain并提供一种易于区分的方法把它与那些起辅助作用的模型和代码分开。最有价值和最专业的概念要轮廓分明。尽量要说Core Domain.**
   
## Generic SubDomain
* 识别出那些与项目意图无关的内聚子领域。把这些子领域的通用模型提取出来，并放到单独的Module中。任何专有的东西都不应该放在这些模块中。
   把他们分离开来以后，在继续开发的过程中，它们的优先级应低于Core Domain的优先级，并且不要分派核心开发人员来完成这些任务(因为他们很少能够从这些任务中获得领域知识).此外，还可以考虑为这些Generic SubDomain使用线程的解决方案或“公开发布的模型(Published Model)”.
* Generic SubDomain是你可以充分利用外部设计专家的地方，因为这些专家不需要深入理解你特有的Core Domain,而且他们也没有太大的机会学习这个领域。机密性问题可以不用过多关注，因为这些模块几乎不涉及专有信息或业务时间。Generic Subdomain可以减轻对那些不了解领域知识的人员进行培训而带来的负担。
* 随着时间的推移，Core 模型的范围将会不断变窄，而越来越多的通用模型将作为框架被实现出来，或者至少被实现为公开发布的模型或分析模式。
* 通用不等于重用
	重用确实会发生，但不一定总是代码重用。模型重用通常是更高级的重用。尽管我们很少考虑设计的可重用性，但通用子领域的设计必须严格地限定在通用概念的范围之内。如果将行业专用的模型元素引入到通用子领域中，会产生两个后果。
	1. 他会妨碍将来的开发。虽然现在我们只需要指令与模型的一部分，但我们的需求会不断增加。如果任何不属于子领域概念的部分引入到设计中，那么再想灵活地扩展系统就很难了，除非完全重建原来的部分并重新设计使用该部分的其他模块。
	2. 这些和行业专用的概念要么属于Core Domain,要么属于它们自己的更专业的子领域，而且这些专业的模型比通用子领域更具价值。
## Domain Vision Statement(模型愿景文档)
* 写一份Core Domain的剪短描述(大约一页纸)以及它将会创造的价值，也就是“价值主张”。那些不能将你的领域模型与其他领域模型区分开的方面就不要写了。展示出领域模型是如何实现和均衡各方利益的。这份描述要尽量精简。尽早把它写出来，随着新的理解随时修改它。
* Domain Vision Statement从宽泛的角度对Core Domain进行了说明，但它把什么是具体核心模型元素留给人们自己去解释和猜测。除非团队的沟通及其充分，否则单靠Vision Statement 很难产生什么效果。

## Highlighted Core
	尽管团队成员可能大体上知道核心领域由什么构成的，但Core Domain中到底包含那些元素，不同的人会有不同的理解，设置同一个人在不同的时间也会有不同的理解。如果我们总是要不断过滤模型以便识别出关键部分，那么就会分散本应该投入到设计上的经历，而且这还需要广泛的模型只是。因此，Core Domain 必须要很容易被分辨出来。
* 精炼文档应该为读者提供一个整体视图，支出各个部分是如何组合到一起的，并且指导读者到相应的代码部分寻找更多的细节。作为Hightlighted Core 的一种形式：编写一个非常剪短的文档(3~7页，每页内容不必太多)，用于描述Core Domain以及Core元素之间的主要交互过程。
  控制这些风险的最好方法是保持绝对的精简。剔除哪些不重要好的细节，只关注核心抽象以及它们的交互，这样文档的老化速度就会减慢，因为这个层次的模型通常更稳定。
* 如果精炼文档概括了Core Domain的核心元素，那么它就可以作为一个指示器——用以指示模型改变的重要程度。当模型或代码的修改影响到精炼文档时，需要与团队其他成员一起协商。当对精炼文档做出修改时，需要立即通知所有团队成员，而且要把新版本的文档分发给他们。Core 外部的修改或精炼文档外部的细节修改则无需协商或通知，可以直接把它们集成到系统中，其他成员在后续工作过程中自然会看到这些修改。这样开发人员就拥有了XP建议的完全的自治性。

## Cohesive Mechanism(内聚机制)
	计算有时会非常复杂，使设计开始变得膨胀。机械性的“如何做”大量增加，把概念性的“做什么”完全掩盖了。为解决问题提供算法的大量方法掩盖了那些用于表达问题的方法。
* 把概念上的Cohesive Mechanism风里刀一个单独的轻量级框架中。要特别注意公司或者那些有完备文档的算法。用一个Intention-Reverling Inteface来暴露这个框架的功能。现在，领域中的其他元素就可以只专注如何表达问题(做什么)了，而把解决方案的复杂细节(如何做)转移给了框架。
* Core Domain 和Generic SubDomain 的模型描述的是事实，规则或问题。而Cohesive Mechanism则用来满足规则或用来完成模型指定的计算。
   Generic SubDomain 与Cohesive Mechanism 的动机是相同的——都是为Core Domain减负。区别在于二者所承担的职责的性质不同。Generic SubDomain是以**描述性的模型**作为基础的，它用这个模型表示出团队会如何看待领域的某个方面。这一点上它和Core Domain没什么区别，只是重要性和专门程度较低而已。Cohesive Mechanism 并不表示领域，它的**目的是解决描述性模型所提出来的一些复杂的计算问题**。模型提出问题，Cohesive Mechanism 解决问题。
* 通过精炼得到声明式风格
	Cohesive  Mechanism 用途最大的地方是它通过Intention-revealing Interface 来提供访问，并且具有概念上一直的Assertion 和Side-effect-free function.利用这些Mechanism 和柔性设计，Core Domain 可以使用有意义的声明，而不必调用难懂的函数。但最不同寻常的回报来自于使Core Domain的一部分产生突破，得到一个深层模型，而且这部分核心领域本身成了一种语言，可以灵活且精确地表达出最重要的应用场景.
	把Generic SubDomain提取出来可以减少混乱，而Cohesive Mechanism 可以把复杂操作封装起来.这样得到一个更专注的模型,减少那些对用户没什么价值的，分散注意力的方面。
	
## SegreGated Core
* 对模型进行重构，把核心概念从支持性元素(包括定义得不清楚的那些元素)中分离出来，并增强Core的内聚性，同时减少它与其他代码的耦合。把所有通用元素或支持性元素提起到其他对象中，并把这些对象放到其他的包中——及时这回把一些紧密耦合的元素分开。
* 重构得到Segregated Core的一般步骤：
	1. 识别出一个Core 子领域(可能是从精炼文档中得到的)。
	2. 把相关的类移到新的Module中，并根据与这些类有关的概念为模块命名。
	3. 对代码进行重构，把那些不直接表示概念的数据和功能分离出来。
	4. 对新的Segregated Core Module 进行重构，使其中的关系和交互变得更简单，表达的更清楚，并且最大限度地减少并澄清它与其他Module的关系(这将是一个持续进行的重构目标)。
	5. 对另一个Core子领域重复这个过程，知道完成Segregated Core 的工作。
* Segregated Core 使我们能够提高Core Domain的内聚性。我们可以使用很多有意义的方式来分解模型，有时在创建Segregated Core时，可以把一个内聚性很好的Module拆分开，通过牺牲这种内聚性来换取Core Domain的内聚性。这样做是值得的，因为企业软件的最大价值来自于模型中企业的那些特有方面。

## Abstract Core 
	当不同Module的子领域之间有大量交互时，那么需要在Module之间创建很多引用，这在很大程度上抵消了划分模块的价值；要么就必须间接的实现这些交互，而后者会使模型变得晦涩难懂。
* 多态性(polymorphism)允许我们忽略抽象类型实例的很多细节变化。如果Module之间的大部分交互都可以做爱多态接口这个层次上表达出来，那么就可以把这些类型重构到一个特定的Core Module中。
* 把模型中最基本的概念识别出来，并分离到不同的类，抽象类或接口中。设计这个抽象模型，使之能够表达出重要组件之间的大部分交互。把这个完整的抽象模型放到它自己的Module中，而专用的，详细的设计类则留在有子领域定义的Module中。
   现在，大部分专用的类都将引用Abstract Core Module,而不是其他专用的Module。Abstract Core(抽象核心)提供了主要概念及其交互的简化视图。
* 如果项目中同时使用了Abstract Core和精炼文档，而且精炼文档随着应用程序理解的加深而不断演变，那么抽象核心的最后结果看起来应该和精炼文档非常类似。当然Abstract Core是用代码编写的，因此更为严格和完整。
* 精炼并不仅限于从整体上把领域中的一部分从Core中分离出来。它也意味着对子领域(特别是Core Domain)进行精炼，通过持续重构得到更深层的理解，从而向深层模型和柔性设计推进。精炼的目标是把模型设计得更明显，使我们可以用模型简单地把领域表示出来。深层模型把领域中最本质的方面精炼成一些简单的元素，使我们可以把这些元素组合起来解决应用程序中的重要问题。






















































