# 大型结构
	无论项目的规模如何，人们总需要有各自的分工，来负责系统的不同部分。如果没有任何协调机制或规则，那么相同问题的各种不同风格和截然不同的解决方案就会混杂在一起，使人们很难理解各个部分是如何组织在一起的，也看不到整个系统的统一视图。从设计的一个部分学到的东西并不适用于这个设计的其他部分，因此项目最后的结果是开发人员成为各自Module的专家，一旦脱离了他们自己的小圈子就无法互相帮助。在这种情况下，Continuous Integration根本无法实现，而Bounded Context也使项目变得支离破碎。
* 在一个大的系统中，如果因为缺少一种全局性的原则而使人们无法根据元素在模式(这些模式被应用于整个设计)中的角色来解释这些元素，那么开发人员就会陷入"只见树木，不见森林“的境地。
* "大型结构"是一种语言，人们可以用它来从大局上讨论和理解系统。设计一种应用于整个系统的规则(或角色和关系)模式，使人们可以通过它在一定程度上了解各个部分在整体中所处的位置(即使是在不知道各个部分的详细职责的情况下)。


## Evoling Order(有序演变)
	一个没有任何规则的设计会产生一些无法理解整体含义且很难维护的系统。但结构中早期的设计假设又会使项目变得束手束脚，而且会极大地限制应用程序中某些特定部分的开发人员/设计人员的能力。很快，开发人员就会为使用结构而不得不在应用程序开发上委曲求全，要么就要完全推翻架构而又回到没有协调的开发老路上来。
* 当发现一种大型结构可以明显使系统变得更清晰，而又没有对模型开发施加一些不自然的约束时，就应该采用这种结构。使用不合适的结构还不如不使用它，因此最好不要为了追求设计的完整性而勉强使用一种结构，而应该找到尽可能精简的方式解决所出现问题，记住宁缺毋滥的原则。


## System Metaphor(系统隐喻)
	System Metaphor 是一种松散的，易于理解的大型结构，它与对象范式是协调的。由于系统隐喻只是对领域的一种类比，因此不同模型可以用近似的方式来与它关联，这使得人们能够在多个Bounded Context中使用系统隐喻，从而有助于协调各个Bounded Context之间的工作。
* 当系统的一个具体类正好符合团队成员对系统的想象，并且能够引导他们向着一个有用的方向进行思考时，就应该把这个类比用作一种大型结构。围绕这个隐喻来组织设计，并把它吸收到Ubiquitous Language中。System Metaphor 应该既能促进系统的交流，又能知道系统的开发。它可以增加系统不同之间的一致性，甚至可以跨越不同的Bounded Context。但所有隐喻都不是完全精确的，因此应不断检查隐喻是否过渡或不恰当，当发现它起到妨碍作用时，要随时准备放弃它。


## Responsibility Layer
	如果每个对象的职责都是认为分配的，将没有统一的指导原则和一致性，也无法把领域作为一个整体来处理。为了保持大模型的一直，有必要在职责分配上实施一定的结构化控制。
* 注意观察模型中的概念依赖性，以及领域中不同部分的变化频率和变化的原因。如果在领域中发现了自然的层次结构，就把他们转换为宽泛的抽象职责。这些职责应该描述系统的高层目的和设计。对模型进行重构，使得每个领域对象，Aggregate和Module的职责都清晰地位于一个职责层当中。
* 层次
	层应该能表达出领域的基本现实或优先级，较高层概念的意义应该依赖较低层，而底层概念的意义应该独立于较高的层。如果不同层的对象必须具有不同的变化频率或原因，那么层应该能容许他们之间的变化。
	* 潜能层
		我们能做什么？潜能层不关心我们打算做什么，而关心能够做什么。
	* 作业层
		我们正在做什么？我们利用这些潜能做了什么事情？像潜能层一样，这个层也应该反映出显示状况，而不是我们设想的状况。
	* 决策支持层
		应该采取什么行动或指定什么策略？这个层用来做出分析和制定决策的。它根据来自较低层(如潜能层或作业层)的信息进行分析。决策支持软件可以利用历史信息来主动寻找适用于当前和未来作业的机会。
	* 策略层
		规则和目标是什么？规则和目标主要是被动的，但它们约束着其他层的行为。**策略层与决策支持层能够进行很好的协作，决策支持层提供了用于搜索策略层所设定的目标的方式，这些目标又收到策略层所设定的规则的约束。**
	* 承诺层
		我们承诺了什么？这个层具有策略层的性质，因为它表述了一些知道未来运营的目标；但它也有作业层的性质，因为承诺是作为后序业务活动的一部分而出现和变化的。


## Knowledge Level
	Knowledge Level 是一组描述了另一组对象应该有哪些行为的对象。
* 当我们需要让用户对模型中的一部分有所控制，而模型又必须满足更大的一组规则时，可以利用Knowledge Level来处理这种情况。它可以使软件具有可配置的行为，其中实体中的角色和关系必须在安装时(甚至在运行时)进行修改。
* 如果在一个应用程序中看，Entity的角色和他们之间的关系在不同的情况下会有很大变化，那么复杂性会显著增加。在这种情况下，无论是一般的模型还是高度定制的模型，都无法满足用户的需求。为了兼顾各种不同的情形，对象需要应用其他的类型，或者需要具备一些在不同情况下包括不同使用方式的属性。具有相同数据和行为的类可能会大量增加，而这些类的唯一作用只是为了满足不同的组装规则。
	简单的例子就是，将一些组合在一个类中的概念,这个概念变量可以有几种类型，那么可以进行抽取出来，作为一个新的抽象的对象，原类只依赖这个抽象对象，实际构建的时候选择合适的抽象对象的某个实现。
	
## Pluggable Component Framework 
	当很多应用程序需要进行操作时，如果所有应用程序都基于相同的一些抽象，但他们是独立设计的，那么在多个Bounded Context之间的转换会限制他们的集成。各个团队之间如果不能紧密地协作，就无法形成一个Shared Kernel.重复和分裂将会增加开发和安装的成本，而且互操作会变得很难实现。
* 从接口和交互中提炼出一个Abstract Core,并创建一个框架，这个框架要求允许这些接口的各种不同实现被自由替换。同样，无论是什么应用程序，只要它严格通过Abstract Core的接口进行操作，那么就可以允许它使用这些组件。
   高层抽象被识别出来，并在整个系统范围内共享，而特化(specialization)发生在Module中。应用程序的中央hub是Shared Kernal内部的Abstract Core。但封装的组件接口可以把多个Bounded Context封装到其中，这样，当多个组件来自不同地方时，或者当组件中封装了用于集成的已有软件时，可以很方便地使用这中结构。




























































