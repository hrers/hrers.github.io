---
layout: post
title:  "领域驱动设计-突破"
date:   2022-10-23 16:50:34 +0800
categories: 领域驱动设计
---
* 目录
{:toc #markdown-toc}

# 突破
	通过一点点的重构可以加深我们对模型的进一步理解，做出更好的设计决策。当领域知识的进一步深化，达到某一种程度即可以清楚的修改领域模型的设计，使得软件的设计提高一个层次。但是同时这种修改相对于一般的重构，回报更多，但是风险也更大。
## 通过重构来加深理解
*  重构
	重构就是在不改变软件功能的前提下重新设计它。开发人员无需在着手开发之前做出详细的设计决策，只需要在开发过程中不断小幅他调整设计即可，这不但能够保证软件原有的功能不变，还可使整个设计更加灵活易懂。
* 为更深层模型重构
	在深入理解领域的基础上进行重构，通常需要实现一系列的代码细节重构，但这么做绝不仅仅是为了改进代码状态。相反，代码细节重构是一组操作方便的修改单元，通过这些重构可以得到更深层次的模型其目标在于：开发人员通过重构不仅能够了解代码实现的功能，还能明白个中原因，并把他们与领域专家的交流联系起来。
*  深层模型的演变
	开发人员识别出设计中隐含的某个概念或是在讨论中受到启发而发现一个概念时，就会对领域模型和相应的代码进行许多转换，在模型中加入一个或多个对象或关系，从而将此概念显示地表达出来。有时，这种从隐式概念到显式概念的转换可能试一次突破，使我们得到一个深层模型。
	但更多时候，突破不会马上到来，而需要我们在模型中显式表达出许多重要概念，并通过一系列重构不断地调整对象职责，改变他们与其他对象的关系，甚至多次修改对象名称，在这之后，突破才会姗姗而来。
## 将隐式概念转化为现实概念
1. 初始领域知识积累
	1.  思考的矛盾与模型的统一
		头脑风暴中，经常会有各人不同的观点。这些观点各有道理，只有统一各种观点才能形成更加完善的模型。
	2. 查阅书籍
	3. 尝试，再尝试
		在对一个事物建立模型的时候我们其实别无选择，只有不断尝试了解什么有效什么无效，**企图避免设计上的失误将会导致开发出来产品质量低劣，因为没有更多的经验可用来借鉴，同时也会比进行一系列快速实验更加费时。**	
		
## 为那些不太明显的概念建模
1. 显式的约束
	* 约束是模型概念中非常重要的类别，他们通常是隐含的，将它们显式地表现出来可以极大地提高设计质量。
	* 将一些重要的隐式约束提取到自己的方法中，这样就可以通过方法名来表达约束的含义，这样就可以通过方法名来表达约束的含义，从而在设计中显式的表现出这条约束。
2. 表明约束正在扰乱"宿主对象"的设计
	1. 计算约束所需的数据从定义上看并不属于这个对象
	2. 相关规则在多个对象中出现，造成了代码重复或导致不属于同一族的对象之间产生了继承关系
	3. 很多设计和需求讨论时围绕这些约束 进行的，而在代码实现中，他们却隐藏在过程代码中

# 规格(Specification)
	规格中声明的是限制另一个对象状态的约束,被约束对象可以存在，也可以不存在。规格有多种用途，其中一种体现了最基本的概念，这种用途是：specification可以测试任何对象以检验它们是否满足指定的标准。
	那些难于控制的测试方法可以巧妙地扩展出自己的对象，它们都是些小的真值测试，可以提取到单独的Value Object中,而这个新对象可以用来计算另一个对象，看看谓词对那个对象的计算是否为“真”。
* 规格的一些应用
	1. 验证对象，检查它是否能满足某些需求或者是否已经为实现某个目标做好了准备
	2. 从集合中选择一个对象
	3. 指定在创建对象时必须满足某种需求



# 柔性设计
## Intention-Reverling Interfaces(释意接口)
	设计中的所有公共元素共同构成了接口，每个元素的名称都提供了解释设计意图的机会。类型名称，方法名称和参数名称组合在一起，共同形成了一个Intention-reverling interfaces
	在命名类和操作时要描述他们的效果和目的，而不要表露它们是通过何种方式达到目的的。这样可以使客户开发人员不必去理解内部细节。这些名称应该与Ubiqutous language 保持一致，以便团队成员可以迅速推断出他们的意义。在创建一个行为之前先为它编写一个测试，这样可以促使你站在客户开发人员的角度上来思考它。
	所有负责的机制都应该封装到抽象接口的后面，接口只表明亿图，而不表明方式。

# Side-Effect-Free function
* 操作分类：
		1. 查询: 从系统获取信息，查询的方式可能这只是简单地访问变量中的数据
			函数：返回结果而不产生副作用的操作
		2. 命令:也成为修改器，是修改系统的操作。
	在一个复杂的设计中，元素之间的交互可能会产生无法预料的结果，即副作用。多个规则的相互作用或计算的组合所产生的结果是很难预测的。
	
* 减少副作用
	1. 将命令和查询严格地放在不同的操作中，确保导致状态改变的方法不返回领域数据，并尽可能保持简单。在不引起任何可观测到的副作用的方法中执行所有查询和计算。 
	2. 使用一些替代的模型和设计，它们不要求对现有对象做任何修改。相反，它们创建并返回一个Value Object，用于表示计算记过。Value Object是不可变的，这意味着除了在创建期间调用的初始化程序之外，他们的所有操作都是函数。
		通过派生出一个Value Object(而不是改变现有状态),或者通过把职责完全转移到一个Value Object中，往往可以完全消除副作用.其实就是类似String api 中，String的一些操作并不会修改String 对象本身的值，而是产生一个新的String对象。

# Assertion
* 断言描述了状态，而不是过程，因此它们更易于分析。类的固定规则在描述类的意义方面起到帮助作用，并且使客户开发人员能够跟准确地预测对象的行为，从而简化它们的工作。如果你确信了后置条件的保证，那么就不必考虑方法时如何工作的。断言应该已经把其他操作的效果考虑在内了.
* 通过类和方法的“断言”使开发人员知道肯定会发生的结果，简言之，“后置条件”描述了一个操作的副作用，也就是调用一个方法之后必然会发生的结果。“前置条件”就像是合同条款，即为了满足后置条件而必须要满足的前置条件。类的固定规则规定了在操作结束时对象的状态。也可以把Aggregate作为一个整体来声明固定规则，这些都是严格定义的完整性规则。
* **Intention-revrealing interface 清楚地表明了用途，Side-effect-free function 和 Assertion 使我们能够更准确地预测结果，因此封装和抽象更加安全。**

# Conceptual Contour
* 在领域中一定存在着某种是十分复杂的原理，否则建模也就失去了意义。由于这种隐藏在底层的一致性，当我们找到一个模型，它与领域的某个部分特别吻合时，这个模型很可能也会与我们后序发现的这个领域的其他部分一致。有时，新的发现可能与模型不符，在这种情况下，就需要对模型进行重构，以便获取更深层的理解，并希望下一次新发现能与模型一致。
* 在做每一个决定时，都要问自己**这是根据当前模型和代码中的特定关系做出的权宜之计呢,还是反映了底层领域的某种轮廓?** 寻找在概念上有意义的功能单元，这样可以使得设计既灵活又易懂。从稍大的范围来看，每个对象都应该是一个独立的，完整的概念，也就是一个“WHOLE VALUE"(整体值). 
* 因此，把设计元素(操作，接口，类和AGGREGATE)分解为内聚的单元，在这个过程中，你对领域中一切重要划分的直观认识也要考虑在内。在连续的重构过程中观察发生变化和保证稳定的规律性，并寻找能够解释这些变化模式的底层Conceptual Contour.使模型与领域中那些一致的方面(正是这些方面使得领域成为一个有用的知识体系)相匹配。
* 我们的目标是得到一组可以在逻辑上组合起来的简单接口，使我们可以用Ubiquitous Language 进行合理的表述，并且使那些无关的选项不会分散我们的注意力，也不增加维护负担。但这通常是通过重构才能得到的结果，很难在前期就实现。而且，如果仅仅是从技术角度进行重构，可能永远也不会出现这种结果，只有通过重构得到更深层的理解，才能实现这样的目标。
* **Intention-revealing interface 使客户能够把对象表示为很有意义的单元，而不仅仅是一些机制。Side-effect-free function 和 Assertion使我们可以安全地使用这些单元，并对它们进行复杂的组合。Conceptual Contour的出现使模型的各个部分变得更加稳定，也使得这些单元更加直观。更易于使用和组合**

# Standalone Class(独立的类)
* 相互依赖使模型和设计变得难以理解，测试和维护。而且，互相依赖很容易越积越多。Module 和 Aggregate 的目的都是为了限制互相依赖的关系网。当我们识别出一个高度内聚的子领域并把它提取到一个Module中的时候，一组对象也随之与系统的其他部分解除了联系，这样就把互相联系的概念的数量控制在一个优先的范围之内。但是，即使把系统分成各个Module,如果不严格控制Module内部的依赖的话，那么Module也一样让我们耗费很多精力去考虑依赖关系。
* 即使在Module内部，设计也会随着依赖关系的增加而变得越来越难以理解。这加重了我们的思考负担，从而限制了开发人员处理的设计复杂度。隐式概念比显示引用增加的负担更大。
* 我们可以将模型一致精炼下去，知道每个剩下的概念关系都表示出概念的基本含义为止。在一个重要的子集中，依赖关系的个数可以减少到零，这样就可以得到一个完全独立的类，它只有很少的几个基本概念和基础库概念。我们应该对每个依赖关系提出质疑，知道证实它确实表示对象的基本概念为止。这个仔细检查依赖关系的过程从提取莫新概念本身开始。然后需要注意每个独立的关联和操作。仔细选择模型和设计能够大幅减少依赖关系——常常能减少到零。
* **低耦合是对象涉及的一个基本素养，尽一切可能保持低耦合。把其他所有无关概念提取到对象之外。这样类就变得完全独立了，这就使得我们可以单独地研究和理解它。每个这样的独立类都极大地减轻了因理解Module而带来的负担。** 
* 当一个类与它所在模块中的其他类存在依赖关系时，比它与模块外部的类有依赖关系要好得多。同样，当两个对象具有自然的紧密耦合关系时，这两个对象共同涉及的多个操作实际上能够把他们的关系本质明确地表示出来。我们的目标不是消除所有依赖，而是消除所有不重要的依赖。当无法消除所有依赖关系时，每清除一个依赖对开发人员而言都是一种解脱，使他们能够集中精力处理剩下的概念依赖关系。
* 尽力把最复杂的计算提取到Standalone Class中，实现此目的的一种方法时从存在大量依赖的类中将Value Object建模出来.**低耦合是减少概念过载的最基本的方法。独立的类是低耦合的极致**

# Closure Of Operation
* 闭合操作： 当我们对集合中的任意两个元素组合时，结果仍在这个集合中.
* 依赖使必然存在的，当一来是概念的一个基本属性时，它就不是坏事。如果把接口精简到只处理一些基本类型，那么会极大地削弱接口的能力。但我们也经常为接口引入不必要的依赖，甚至是整个不必要的概念。
* **在适当的情况下，在定义操作时让他们的返回类型与其参数的类型相同。如果实现者(Implementer)的状态在计算中会被用到，那么实现着实际上就是操作的一个参数，因此参数与返回值应该与实现者有相同的类型。这样的操作就是在该类型的实例集合中的闭合操作。闭合操作提供了一个高层接口，同时又不会引入对其他概念的任何依赖**j 
* 这种模式更常用于Value Object 的操作，由于Entity 的生命周期在领域中十分重要，因此我们不能为了解决某一问题而草率创建一个Entity。有一些操作是Entity 类型之下的闭合操作。我们可以通过查询一个Employee 兑现来返回其主管，而操作的僵尸另一个Employee 对象。但是Entity 通常不会成为计算结果，因此，大部分闭合操作都应该到Value Object 中去寻找。
* **半个闭合操作** : 参数类型与**实现者(Implementer)** 的类型一致，但返回类型不同；或者返回类型与**接受者(Receriver)** 的类型相同，但参数类型不同。这些操作都不是闭合操作，但他们确实具有Closure Of Operation的某些优点。当没有形成闭合操作的那个多出来的基本类型或基础库类时，它几乎与Closure Of Operation一样减轻了我们的思考负担。
```java
半闭合：参数类型与实现者的类型一直，但返回类型不同
Implementer{
	public Reveiver operate(Impletementer argument){
	}
}
半闭合：返回类型与接受者的类型相同，但参数类型不同
Receiver{
	Receiver someMethodNeedToUseImplementerOperatie(Impletementer argument){
		return Impletementer.operate(argument);
	}
}
全闭合:闭合操作
ClosureOfOperation{
	public ClosureOfOpetation operate(ClosureOfOperation coo){
		return ClosureOfOpetation; 
	} 
}
```

# 声明式设计
* 声明式设计对于不同的人来说具有不同的意义，但通常是指一种编程方式——**把程序或程序的一部分写成一种可执行的规格(specification).使用声明式设计时，软件实际上是由一些非常精确的属性描述来控制的。** 如，and(not(armored),not(Ventilated))。  
* 声明式设计有很多种实现方式，例如，通过反射机制来实现，或在编译时通过代码生成来实现(根据声明来自动生成传统代码),如Java JDK代理是通过反射实现，cgLib代理这通过字节码处理框架进行自动生成字节码进行扩展。这种方法使其他开发人员能够根据字面意义来使用声明，它是一种绝对的保证.
* 从模型属性的声明来生成可运行的程序是DDD的理想目标，但声明式编程实践中有其存在的问题
	1. 声明式语言并不足以表达一切所需的东西，它把软件束缚在一个由自动部分构成的框架之内，使软件很难扩展到这个框架之外
	2. 代码生成技术破坏了迭代循环——它把生成的代码合并到手写的代码中，使得代码重新生成具有巨大的破坏作用
* 尽管基于规则的程序原则上是声明式的，但大多数系统都有一些用于性能优化的“控制谓词(Control Predicate)”，这种控制代码引入了副作用，这样行为就不再完全由声明式规则来控制了。添加，删除规则或重新排序可能导致预料不到的错误结果。因此，编写逻辑的程序员必须确保代码的效果是显而易见的，就像对象程序员所做的那样。很多声明式方法被开发人员有意或无意忽略之后找到破坏。当系统很难使用或限制过多时，就会发生这种情况。为了声明式程序的好处，每个人都必须遵守框架的规则。
* 声明式设计发挥的最大价值是用一个范围非常狭窄的框架来自动处理设计中某个特别单调且易出错的方面，如持久化和对象关系映射。最好的声明式设计能够使开发人员不必去做哪些单调乏味的工作，同时又完全不限制它们的设计自由。
* 声明式风格例子
	![](https://gitee.com/dlulianzi/blogimage2/raw/master/img/20220911223639.png)
	
	<center>COMPOSITE design of SPECIFICATION</center>

* 包容
	包容体现在如后序编写的逻辑要兼容前面的逻辑，Specification 变得严格了，新的Specification 要包容旧的Specification. 但是如果包容设计的逻辑变换使得系统复杂度升高，那么在大多数时候应当避免出现这样的复杂性：要么选择放弃一些运算符，要么不使用包容。如果这两者同时需要，那么要慎重考虑这样做的价值是否多过他所带来的麻烦。

# 应用分析模式
## 分析模式
	《分析模式》：分析模式是一种概念集合，用来表示业务建模中的常见结构。它可能只与一个领域有关，也可能跨越多个领域。
	
# 将设计模式应用于模型
## Strategy(也称Policy)
	定义一组算法，将每个算法封装起来，并使他们可以互换.Strategy 允许算法独立于使用它的客户而变化。
* 我们需要把过程中的一边部分提取到模型的一个单独的“策略”对象中。将规则与它所控制的行为区分开。按照Strategy设计模式来实现规则或可替换过程。策略对象的多个版本表示了完成过程的不同方式。通常，作为设计模式的Strategy 侧重于替换不同算法的能力，而当其作为领域模型时，其侧重点则是表示概念的能力，这里的概念通常是指过程或策略规则。
## Composite
	将对象组织成树来表示部分-整体的层次结构。利用Composite，客户可以对单独的对象和对象组合进行同样的处理。
* 定义一个把Composite的所有成员都包含在内的抽象类型。在容器上实现那些查询信息的方法时，这些方法返回由容器内容所汇总的信息。而“叶”节点则基于它们自己的值来实现这些方法。客户只需使用抽象类型，而无需区分“叶”和容器。
* 相对而言，这是一种明显的结构层面商店模式，但设计人员通常不会主动充实它的操作方面。Composite模式在每个结构层上都提供了相同的行为，无论较小的部分还是较大的部分，都可以对这些部分必出一个有意义的问题，这些问题能够透明地反映出他们的构成情况。这种严格的对称是组合模式具有强大能力的关键所在。

# 通过重构得到更深层的理解
* 开始重构
	与传统重构观点不同的是，及时在代码看上去很整洁的时候也可能需要重构，原因是模型的语言没有与领域专家保持一致，或者新需求补鞥呢被自然地添加到模型中。重构的原因也可能来自学习：当开发人员通过学习获得了更深刻的理解，从而发现了一个得到更清晰或更有用的模型的机会。
* 开发团队探索
	1. 自主决定
		可以随时组成一个小的团队来研究某个设计问题。这个团队只工作几天，然后就可以解散了。这种团队没有长期存在的必要，也不必有复杂的组织结构
	2. 注意范围和休息
		在几天内召开两三次短会就应该能够产生一个值得尝试的设计。工作拖得太多就并没有好处。如果讨论毫无进展，可能是一次讨论的内容太多了。选一个较小的设计方面，集中讨论它。
	3. 练习使用Ubiquitous Language
		让其他团队成员(特别是主题专家)参与头脑风暴会议是练习和精华Ubiquitous Language的好机会。这样，原来的开发人员可以得到更完善的Ubuquitos Language,并反映到编码中。
* 借鉴先前的经验
	1. 通过领域相关的书籍进行知识获取，组织相关概念，对只是进行抽象，快速得到一个结果并与专家一起讨论。
	2. 从分析模式中汲取他人的经验。这些经验对于帮助我们读懂领域起到了一定的作用，但分析模式是专门针对软件开发的，因此应该直接根据我们自己在领域中实现软件的经验来利用这些模式。分析模式可以提供惊喜的模型概念，并帮助我们避免很多错误，但他们并不是线程的“菜谱”。他们只是为知识消化过程提供了一些供给。
	3. 善于在领域中使用线程的设计模式，特别是当设计模式既符合实现需求，有符合模型概念时。
	4. 对于一些常见的形式体系(如算数逻辑或谓词逻辑)与领域中的某个部分非常符合时，可以把这个部分提取出来，并根据它来修改形式系统的规则。则可以产生非常简练且易于理解的模型。
* 针对开发人员的设计
	软件不仅仅是为用户提供的，也是为开发人员提供的。开发人员必须把他们编写的代码与系统的其他部分集成到一起。在迭代过程中，开发人员反复修改代码。开发人员应该通过重构得到更深层的理解，这样技能实现柔性设计，也能从这样一个设计中获益。
	柔性设计能够清除的表明它的意图。这样的设计使人们很容易看出代码的运行效果，因此也很容易预计修改代码的结果。柔性设计主要通过减少依赖性和副作用来减轻人们的思考负担。这样的设计是以深层次的领域模型为基础的，在模型中，只有那些对用户最重要的部分才具有较细的粒度。再这样的模型中，那些经常需要修改的地方能够保持很高的灵活性，而其他地方则相对比较简单。
* 重构的时机
	* 持续重构渐渐被认为是一种“最佳实践“，在探索领域的过程中，在培训开发人员的过程中，以及在开发人员与领域转件进行思想交流的过程中，必须始终把”通过重构得到更深层理解“作为这些工作的一部分。当分身以下情况是，就应该进行重构了
		1. 设计没有表达出团队对领域的最新理解
		2. 重要的概念被隐藏在设计中了(而且你已经发现了把他们呈现出来的方法)
		3. 发现了一个能领某个重要的设计部分变得灵活的机会
* 危机就是机遇
	传统意义上的重构听起来是一个非常稳定的过程。但通过重构得到更深层理解往往不是这样的。在堆模型进行一段时间稳定的改进后，你可能突然有所顿悟，而这会改变模型中的一切。这是对于原有模型漏洞的发现，或对原有模型错误概念的一些调整，而这些都是系统的危机。
	通过重构得到更深层次理解是一个持续不断的过程，人们发现一些隐含的概念，并把他们明确地表示出来。有些设计部分变得更具有柔性，获取还采用了声明式的风格。开发工作一下子到了突破的边缘，然后开发人员跨越这条界线，得到了一个更深层的模型，接下来又重新开始了稳步的改进过程。

















































